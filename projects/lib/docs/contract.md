# Map Framework Contracts

Целевая версия OpenLayers: 6.5.0.

## Цель

Фреймворк позволяет декларативно описывать слои и взаимодействия, а реализация берёт на себя:
- создание слоёв/фич по `MapSchema`;
- синхронизацию модели и геометрии;
- применение LOD-стилей и состояний;
- батчинг обновлений;
- опциональную кластеризацию на уровне слоя.

`types.ts` — единственный источник типов. Этот документ описывает поведение и семантику.

## Hit-test и маршрутизация событий

### Базовое правило hit-test
- Hit-test выполняется по слоям сверху вниз.
- В обработчики передаются `HitItem[]` **только текущего слоя**.
- Порядок элементов в `items` не гарантируется; приоритет выбирается в обработчике.

### Propagation (прокидывание события вниз)
- Любой обработчик может пометить событие как обработанное, вернув `true`.
- Дальнейшая обработка по слоям управляется `InteractionBase.propagation`:
  - `stop` — по умолчанию прекращает обработку на нижних слоях.
  - `continue` — продолжает обработку на нижних слоях.
  - `auto` — зарезервировано (трактуется как `stop`).

### Конфликт click vs select
- Для одного физического клика используется единый pipeline (hit-test → interactions).
- Если у слоя включены и `select`, и `click`, порядок вызовов:
  1) `select`
  2) `click`
- Если `select` вернул `handled=true` и `select.propagation !== 'continue'`,
  то `click` на этом слое не вызывается.

## Hover / Select / Click

- `hover` использует пары `onEnter`/`onLeave` по набору фич, попавших под курсор.
- `select` использует `onSelect` и `onClear` для слоя.
- `click` и `doubleClick` — одноразовые события без жизненного цикла; если нужен временный highlight,
  его следует задавать вручную в обработчиках.
- `click` и `doubleClick` вызываются при клике по карте даже если `items` пустой
  (под курсором нет фич слоя).

## Translate / Modify (drag & drop / редактирование)

### Общий принцип
- В момент старта фреймворк выполняет hit-test на текущем слое и формирует `candidates`.
- Если `pickTarget` задан, он выбирает **единственную** цель из `candidates`.
- Если `pickTarget` не задан — берётся первый кандидат.
- Возврат `null/undefined` из `pickTarget` означает «не стартовать» эту интеракцию,
  но не помечает событие как обработанное.

### Стабильность цели
- Цель фиксируется по ключу модели и **разрешается заново** перед каждым `onStart/onChange/onEnd`.
- Если модель/фича больше не найдена, интеракция завершается без вызова последующих хуков.
- Перевыбор цели во время `onChange` не выполняется.

### Throttle
- `moveThrottleMs` ограничивает частоту `onChange` для translate/modify.

### Нативный режим Modify
- Для `modify` всегда используется нативный `ol/interaction/Modify`.
- Отображаются хэндлы вершин (overlay) и доступна настройка их внешнего вида
  через `modify.vertexStyle`.
- Обновление модели происходит при завершении редактирования (modifyend).

## Кластеризация

- Кластеризация активируется через `LayerClustering` на уровне слоя.
- При hit-test:
  - если cluster-size === 1, кластер разворачивается в обычную фичу;
  - если cluster-size > 1, интеракции слоя **не** запускаются (кластер — отдельная сущность).
- Поведение для кластеров задаётся через `clustering.popup` и `clustering.expandOnClick`.
- При отображении кластеров:
  - для size === 1 используется обычный стиль фичи;
  - `clusterStyle` применяется только при size > 1.

## Popup-поведение

- Фичи и кластеры не рендерят popup напрямую — они формируют `PopupItem`.
- Сбор и отображение выполняет глобальный `PopupHostApi`.
- Поля `PopupItem` используются так:
  - `dedupKey` — ключ для дедупликации;
  - `priority` — порядок сортировки;
  - `source` — источник элемента (feature/cluster/interaction).
- `popupHost.autoMode`:
  - `off` — управление показом вручную;
  - `click`/`hover` — автопоказ по событию.
- `popupHost.stack` определяет, как несколько источников взаимодействуют между собой.

## Батчинг и scheduler

- `invalidate()` и события изменений собираются в батч.
- Политика сброса задаётся `FlushPolicy`:
  - `microtask` — по умолчанию;
  - `raf` — предпочтительно для drag/анимаций.
- Глобально:
  - `MapSchema.options.scheduler.policy` задаёт политику по умолчанию;
  - `interactionPolicy` применяется для `translate/modify`.
- Локально:
  - `MapContext.batch(fn, { policy })` позволяет выбрать политику для конкретной группы операций.

## События изменения моделей

- Изменения, инициированные картой (`mutate/translate/modify`), публикуются через `onModelsChanged`.
- К моменту вызова:
  - модель уже обновлена;
  - геометрия синхронизирована;
  - `invalidate` запланирован;
  - изменения могут приходить батчами.
- Для `mutate/mutateMany` доступны опции:
  - `reason` (по умолчанию `'mutate'`);
  - `silent` (по умолчанию `false`), чтобы не эмитить `onModelsChanged` при сохранении синхронизации.

## Управление коллекцией моделей слоя

### Источник правды

- Источник правды — массив моделей слоя.
- Все операции управления коллекцией приводят к замене массива целиком.
- Порядок моделей сохраняется, новые модели добавляются в конец.

### Уникальность id

- Уникальность id обязательна при любых операциях.
- `setModels` валидирует уникальность входного массива.
- `addModel/addModels` валидируют дубликаты относительно текущих моделей и внутри batch.
- При нарушении уникальности выбрасывается `DuplicateModelIdError` с полями `id` и `layerId`.
- При ошибке состояние коллекции не меняется и событие не публикуется.

### События onModelsCollectionChanged

- Событие относится только к внешним операциям управления коллекцией (`set/add/remove/clear`).
- Изменения, инициированные картой (`drag/modify/mutate`), сюда не попадают.
- Коллбэк вызывается синхронно после применения изменений.
- `prev` и `next` — иммутабельные снимки состояния коллекции до/после операции.
- Событие ровно одно на операцию, даже если реализация использует sugar над `setModels`.
- Diff гарантирован для причин `add/remove/clear`; для `set` может отсутствовать.

### No-op поведение

- `removeModelsById` не эмитит событие, если ничего не удалено.
- `clear` на пустом слое считается no-op и не эмитит событие.
