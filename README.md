# AurOpenlayers — декларативная надстройка над OpenLayers для Angular

AurOpenlayers — это фреймворк-обёртка над OpenLayers, который позволяет описывать слои, фичи, стили и интеракции декларативно, через `MapSchema`. Вместо ручной сборки слоёв, синхронизации бизнес‑модели и геометрии, а также управления хит‑тестом и состояниями, вы описываете контракт поведения и отдаёте его движку.

## Какую проблему решает

При прямом использовании OpenLayers в приложениях чаще всего возникают системные проблемы:

- **Императивная связка бизнес‑модели и карты.** Необходимо вручную создавать `Feature`, следить за жизненным циклом, пересчитывать геометрию и стили при каждом обновлении модели.
- **Разрозненная логика интеракций.** Hit‑test, hover/select/click/drag реализуются по-разному в разных местах, что приводит к конфликтам порядка обработки событий.
- **Неявные правила производительности.** Обновления геометрии и стилей «сыпятся» в карту без батчинга и понятной политики сброса.
- **Повторяемый инфраструктурный код.** Кластеризация, popup‑хост, управление слоями и контекстом приходится писать заново в каждом проекте.
- **Расхождение источника данных и изменений.** Модель может редактироваться в обход слоя, из‑за чего теряется единый источник правды и сложно синхронизировать drag/modify с внешним состоянием.

Фреймворк превращает эти задачи в декларативный контракт: слой описывается через `VectorLayerDescriptor`, интеракции и жизненный цикл — через `FeatureDescriptor`, а глобальные правила — через `MapSchema.options` и контракт поведения (`contract.md`).

## Как это решается фреймворком

**1) Декларативный контракт.**
Все ключевые элементы описываются в `MapSchema`: набор слоёв, правила поведения, глобальные опции (scheduler, popup‑host). Это становится единым источником правды для карты.

**2) Синхронизация модели и геометрии.**
Каждая фича задаёт преобразования `model → geometry` и `geometry → model`. Это делает слой двусторонним: карта может инициировать изменения модели через translate/modify, а обновления из бизнес‑логики автоматически отражаются на карте.

**3) Предсказуемые интеракции.**
Hit‑test, propagation, порядок select/click, правила hover, drag и modify описаны в контракте поведения. Это избавляет от «микро‑багов» при росте сценариев использования.

**4) Управляемая производительность.**
Система батчинга и политика сброса (`microtask`/`raf`) позволяют контролировать частоту invalidation и обновлений, что особенно важно при drag или анимациях.

**5) Инфраструктура «из коробки».**
Кластеризация на уровне слоя, глобальный popup‑host, единые правила hit‑test и state‑стилей — это базовые элементы фреймворка, а не разрозненные утилиты.

**6) Единый источник правды для изменений.**
Слой выступает источником данных: обновления идут через `mutate`/`mutateMany`, а обратная синхронизация с внешней моделью — через `onModelsChanged`. Это снимает проблему расхождения данных и упрощает обработку drag/modify сценариев.

## Архитектура и ключевые сущности

- **`MapSchema`** — описание карты и слоёв, включая глобальные опции (`scheduler`, `popupHost`).
- **`VectorLayerDescriptor`** — описание слоя: id, видимость, z‑index, feature, опциональная кластеризация.
- **`FeatureDescriptor`** — описание фичи: синхронизация геометрии, стиль, интеракции, popup‑логика.
- **`MapContext`** — типизированный доступ к слоям, батчингу, popup‑host и карте.
- **`contract.md`** — контракт поведения интеракций и правил обработки событий (hit‑test, propagation, порядок обработчиков).

## Get started

### 1) Минимальный пример карты

Ниже минимальный пример из demo: один слой точек, базовый стиль и установка моделей через `MapContext`.

```ts
import { Component } from '@angular/core';
import type Geometry from 'ol/geom/Geometry';
import CircleStyle from 'ol/style/Circle';
import Fill from 'ol/style/Fill';
import Stroke from 'ol/style/Stroke';
import Style from 'ol/style/Style';
import Text from 'ol/style/Text';
import {
  MapContext,
  VectorLayerDescriptor,
} from '../../../../lib/src/lib/map-framework';
import { MapHostComponent, MapHostConfig } from '../shared/map-host/map-host.component';
import {
  applyGeometryToMapPoint,
  mapPointToGeometry,
  MapPoint,
  MapPointGenerator,
} from '../shared/map-point';

const POINTS = new MapPointGenerator().getByCount(3);

type PointStyleOptions = {
  color: string;
  radius: number;
  label: string;
};

@Component({
  selector: 'app-simple-map',
  standalone: true,
  imports: [MapHostComponent],
  templateUrl: './simple-map.component.html',
  styleUrl: './simple-map.component.scss',
})
export class SimpleMapComponent {
  readonly mapConfig: MapHostConfig<
    readonly VectorLayerDescriptor<MapPoint, Geometry, PointStyleOptions>[]
  > = {
    schema: {
      layers: [
        {
          id: 'points',
          feature: {
            id: (model: MapPoint) => model.id,
            geometry: {
              fromModel: mapPointToGeometry,
              applyGeometryToModel: applyGeometryToMapPoint,
            },
            style: {
              base: (model: MapPoint) => ({
                color: '#1976d2',
                radius: 6,
                label: model.name,
              }),
              render: (opts: PointStyleOptions) =>
                new Style({
                  image: new CircleStyle({
                    radius: opts.radius,
                    fill: new Fill({ color: opts.color }),
                    stroke: new Stroke({ color: '#ffffff', width: 2 }),
                  }),
                  text: new Text({
                    text: opts.label,
                    offsetY: 18,
                    fill: new Fill({ color: '#1f2937' }),
                    stroke: new Stroke({ color: '#ffffff', width: 3 }),
                    font: '600 12px "Inter", sans-serif',
                  }),
                }),
            },
          },
        },
      ],
    },
    view: {
      centerLonLat: [27.5619, 53.9023],
      zoom: 11,
    },
    osm: true,
  };

  onReady(ctx: MapContext): void {
    ctx.layers['points']?.setModels(POINTS);
  }
}
```

Пример живёт в `projects/demo` (см. `simple-map`).

### 2) Конфигурация карты: что важно в любом проекте

Обёртка карты может отличаться в разных приложениях, но **ядро конфигурации всегда одинаковое**:

- `MapSchema` — единый источник правды по слоям, интеракциям, стилям и глобальным опциям карты.
- `MapSchema.options.scheduler` — определяет политику батчинга (полезно для drag/modify и анимаций).
- `MapSchema.options.popupHost` — общий хост для popup‑элементов, если они нужны в проекте.

View‑параметры (`centerLonLat`, `zoom`, `minZoom`, `maxZoom`) относятся к конкретной реализации wrapper‑компонента, поэтому задаются так, как это принято в вашем приложении. Пример реализации есть в demo (`shared/map-host`).

### 3) Рекомендуемая архитектура: компонент‑обёртка над картой (Angular‑подход)

В production‑проектах карта — это отдельный инфраструктурный контур. **Рекомендуется** выделять собственную обёртку (по образцу demo `MapHostComponent`) как единый вход для карты. Обёртка нужна для:

- **Изоляции OpenLayers от Angular‑рендера.** Работа карты вынесена в `runOutsideAngular`, что предотвращает лишние change‑detection циклы при интеракциях и перемещениях карты.
- **Централизации жизненного цикла.** Компонент корректно создаёт карту, управляет resize‑observer и освобождает ресурсы в `ngOnDestroy`.
- **Единой точки подключения контроллеров.** Через `controllers` подключаются любые сценарии управления картой (режим редактирования, выделение, синхронизация с формами и т.д.).
- **Инкапсуляции общего UX.** Здесь удобно держать базовый tile‑слой, политику масштабирования, интеграцию с popup‑хостом или кастомными оверлеями.

Практическая рекомендация: в вашем приложении создайте свой `shared/map-host`, переиспользуя подход из demo. Это снижает связность между UI‑слоями и картой и даёт стабильный контракт для команды.

### 4) Рекомендации по работе с моделями и изменениями

Чтобы избежать расхождений между картой и доменной моделью, придерживайтесь следующих правил:

- **Меняйте данные только через API слоя.** Используйте `setModels`, `mutate`, `mutateMany`, `setFeatureStates` — это гарантирует корректную синхронизацию геометрии, состояний и перерисовку слоя.
- **Подписывайтесь на изменения, инициированные картой.** Для drag/modify используйте `onModelsChanged` — там приходят изменения с причиной (`mutate/translate/modify`). Это единственный надёжный канал, чтобы синхронизировать изменения с внешним состоянием и формами.
- **Не манипулируйте `ol/Feature` напрямую.** Прямая работа с фичами обходит контракт и может привести к рассинхронизации. Все изменения проходят через `MapContext` и `VectorLayerApi`.
- **Группируйте изменения в батчи.** При массовых обновлениях используйте `MapContext.batch` и политику `raf` для интерактивных сценариев, чтобы избежать лишних invalidation и «дёрганий» карты.
- **Держите все состояния стилей в одном месте.** `FeatureDescriptor.style.states` описывает весь набор возможных состояний (hover/select и т.д.), а затем ими можно управлять через интеракции или `setFeatureStates`. Это снижает количество расхождений и делает поведение прозрачным для команды.

### 4.1) Как правильно работать с изменениями (ключевые правила)

- **Источник данных — слой.** Слой (`VectorLayerApi`) является единственным источником правды по моделям на карте. Не держите параллельную «копию правды» вне слоя без синхронизации.
- **Вносите изменения через `mutate` / `mutateMany`.** Эти методы гарантируют корректную синхронизацию геометрии, стилей и перерисовку слоя; прямое изменение моделей в обход слоя приводит к рассинхронизации.
- **Актуализируйте изменения через `onModelsChanged`.** Подписывайтесь на `onModelsChanged` и обновляйте внешнее состояние (формы, сторы, сервисы) при любом изменении, инициированном картой (drag/modify/mutate). Это «официальный» канал обратной синхронизации с доменной моделью.

### 5) Рекомендации по внедрению в Angular‑проект

1. **Выделите слой инфраструктуры карты.**
   Создайте `shared/map-host`, где сосредоточите создание `Map`, `LayerManager` и `MapContext`.
2. **Опишите доменные типы моделей и их геометрию.**
   Для каждой доменной сущности определите `FeatureDescriptor` с `fromModel/applyGeometryToModel`.
3. **Сделайте слои независимыми.**
   Каждый `VectorLayerDescriptor` должен быть автономным: свой id, правила стилей и интеракций.
4. **Используйте `MapContext` для управляемых операций.**
   `setModels`, `mutate`, `invalidate`, `setFeatureStates` — всё в одном API, без прямых манипуляций `ol/Feature`.
5. **Подключайте интеракции декларативно.**
   Правила обработки hover/select/click/translate/modify описывайте в `FeatureDescriptor.interactions` и используйте `contract.md` как источник поведения.

## Полезные ссылки

- Demo‑примеры: `projects/demo` (см. папку `projects/demo/src/app`).
- Типы API: `projects/lib/src/lib/map-framework/public/types.ts`.
- Контракт поведения: `projects/contract.md`.

## Версии

- 0.0.2 — Angular 19, OpenLayers 6.5.0
- 0.0.3 — Angular 19, OpenLayers 6.5.0
